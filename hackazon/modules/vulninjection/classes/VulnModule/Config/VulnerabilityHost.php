<?php
/**
 * Created by IntelliJ IDEA.
 * User: Nikolay Chervyakov 
 * Date: 01.12.2014
 * Time: 11:56
 */


namespace VulnModule\Config;


use App\Core\Request;
use Symfony\Component\Validator\Constraints;
use Symfony\Component\Validator\Mapping\ClassMetadata;
use VulnModule\DataType\ArrayObject;
use VulnModule\Exception\MissingFieldVulnerabilityException;
use VulnModule\Exception\MissingVulnerabilityInTreeException;
use VulnModule\Vulnerability;

class VulnerabilityHost
{
    /**
     * @var VulnerableElement
     */
    protected $vulnTree;

    /**
     * @var VulnerableElement
     */
    protected $matchedElement;

    /**
     * @var Request
     */
    protected $request;

    /**
     * @var string
     */
    protected $name;

    /**
     * @var array
     */
    public static $targets = [
        Vulnerability::TARGET_CONTEXT,
        Vulnerability::TARGET_FIELD
    ];

    function __construct($name = null, VulnerableElement $vulnTree = null)
    {
        $this->name = $name;
        $this->vulnTree = $vulnTree ?: VulnerableElement::create();
        $this->vulnTree->setHost($this);
    }

    /**
     * @param Request $request
     * @return VulnerableElement
     */
    public function match(Request $request)
    {
        return $this->vulnTree->match($request);
    }

    /**
     * Retrieves custom vulnElement
     * @return VulnerableElement
     */
    public function getVulnerabilityElement()
    {
        return $this->vulnTree;
    }

    /**
     * Retrieves vuln element which matches the request.
     * @return void|VulnerableElement
     */
    public function getMatchedVulnerabilityElement()
    {
        if (!$this->matchedElement) {
            $this->matchedElement = $this->match($this->getRequest());

            if (!$this->matchedElement) {
                $this->matchedElement = $this->vulnTree;
            }
        }

        return $this->matchedElement;
    }

    /**
     * @param $name
     * @param bool $onlyRoot
     * @return null|Vulnerability
     */
    public function getVulnerability($name, $onlyRoot = false)
    {
        $matched = $onlyRoot ? $this->vulnTree : $this->getMatchedVulnerabilityElement();
        return $matched->getComputedVulnerability($name, $onlyRoot ? VulnerableElement::COMPUTE_ONLY_ROOT : 0);
    }

    /**
     * @param Request $request
     */
    public function setRequest(Request $request)
    {
        $this->request = $request;
    }

    /**
     * @return Request
     */
    public function getRequest()
    {
        return $this->request;
    }

    /**
     * Traverses up to the root of the context tree and searches the acceptable vulnerability
     * @param $name
     * @param VulnerabilityHost $startNode
     * @param FieldDescriptor $descriptor
     * @param bool $onlyRoot
     * @return null|Vulnerability
     */
    public function getParentVulnerability($name, VulnerabilityHost $startNode = null, FieldDescriptor $descriptor = null,
                                           $onlyRoot = false)
    {
        if ($startNode === null) {
            $startNode = $this;
        }
        $dependencyChain[] = $this;

        if ($this === $startNode) {
            return $this->_getParentVulnerabilityFromStartNode($name, $startNode, $descriptor, $onlyRoot);

        } else {
            return $this->_getParentVulnerabilityFromParentNode($name, $startNode, $descriptor, $onlyRoot);
        }
    }

    /**
     * @param array $checkChain
     * @return array|Field[]|Context[]|VulnerabilityHost[]
     */
    public function getCheckChain($checkChain = [])
    {
        $checkChain[] = $this;
        if ($this->getParent()) {
            $checkChain = $this->getParent()->getCheckChain($checkChain);
        }
        return $checkChain;
    }

    /**
     * Find desired vulnerability in the parent nodes, or catch exception in case there is no vulnerabilities.
     * @param $name
     * @param VulnerabilityHost $startNode
     * @param FieldDescriptor $descriptor
     * @param bool $onlyRoot
     * @return null|Vulnerability
     */
    public function _getParentVulnerabilityFromStartNode(
            $name, VulnerabilityHost $startNode = null, FieldDescriptor $descriptor = null, $onlyRoot = false)
    {
        if ($this->getParent()) {
            try {
                if ($this->getParent()->hasOwnVulnerability($name)) {
                    return $this->getParent()->getVulnerability($name, $onlyRoot);
                } else {
                    return $this->getParent()->getParentVulnerability($name, $startNode, $descriptor, $onlyRoot);
                }

            } catch (MissingFieldVulnerabilityException $e) {
                return $this->getParent()->getParentVulnerability($name, $startNode, null, $onlyRoot);

            } catch (MissingVulnerabilityInTreeException $e) {
                return null;
            }

        } else {
            return null;
        }
    }

    /**
     * Find desired vulnerability into itself and the parent nodes, or throw an exception in case there is no vulnerabilities.
     * @param $name
     * @param VulnerabilityHost $startNode
     * @param FieldDescriptor $descriptor
     * @param bool $onlyRoot
     * @return null|Vulnerability
     */
    public function _getParentVulnerabilityFromParentNode(
            $name, VulnerabilityHost $startNode = null, FieldDescriptor $descriptor = null, $onlyRoot = false)
    {
        if ($this->hasOwnVulnerability($name)) {
            return $this->getVulnerability($name, $onlyRoot);

        } else {
            try {
                if ($this->getParent()) {
                    return $this->getParent()->getParentVulnerability($name, $startNode, $descriptor, $onlyRoot);
                } else {
                    throw new MissingVulnerabilityInTreeException();
                }
            } catch (MissingVulnerabilityInTreeException $e) {
                return null;
            }
        }
    }

    /**
     * @return null|VulnerabilityHost
     */
    public function getParent()
    {
        return null;
    }

    /**
     * @param VulnerabilityHost $parent
     */
    public function setParent(VulnerabilityHost $parent)
    {
    }

    /**
     * @param $name
     * @param bool $onlyRoot
     * @return bool
     */
    public function hasOwnVulnerability($name, $onlyRoot = false)
    {
        $matchedElement = $onlyRoot ? $this->vulnTree : $this->getMatchedVulnerabilityElement();
        return $matchedElement ? $matchedElement->hasVulnerabilityInTree($name) : false;
    }

    /**
     * @param null $name
     */
    public function clearCache($name = null)
    {
        $this->matchedElement = null;
        if ($this->vulnTree) {
            $this->vulnTree->clearCache($name);
        }
    }

    /**
     * @param VulnerableElement $vulnTree
     */
    public function setVulnTree(VulnerableElement $vulnTree)
    {
        $vulnTree->setHost($this);
        $this->vulnTree = $vulnTree;
        $this->clearCache();
    }

    /**
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    public static function loadValidatorMetadata(ClassMetadata $metadata)
    {
//        $metadata->addPropertyConstraints('name', [
//            //new Constraints\NotNull(),
//            new Constraints\NotBlank(['message' => 'Name cannot be blank.']),
//        ]);
    }

    /**
     * @return VulnerableElement
     */
    public function getVulnTree()
    {
        return $this->vulnTree;
    }

    public function isVulnerableTo($name)
    {
        return $this->getVulnerability($name)->isEnabled();
    }

    public function getPath()
    {
        $path = $this->getParent() ? $this->getParent()->getPath() . '->' : '';
        return  $path . $this->getName();
    }

    public function getVulnElementByPath($path, $createOnMissing = true)
    {
        $parts = preg_split('/->/', $path);
        unset($parts[0]);

        $element = $this->getVulnerabilityElement();
        if (count($parts)) {
            return $element->getElementByPath(implode('->', $parts), $createOnMissing);
        }

        return $element;
    }
}