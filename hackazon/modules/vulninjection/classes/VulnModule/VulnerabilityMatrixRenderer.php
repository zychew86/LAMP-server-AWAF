<?php
/**
 * Created by IntelliJ IDEA.
 * User: Nikolay Chervyakov 
 * Date: 05.02.2015
 * Time: 12:28
 */


namespace VulnModule;


use VulnModule\Config\ConditionalVulnerableElement;
use VulnModule\Config\Context;
use VulnModule\Config\Field;
use VulnModule\Config\VulnerabilityHost;
use VulnModule\Config\VulnerableElement;
use VulnModule\Storage\IReader;

class VulnerabilityMatrixRenderer
{
    protected $reader;

    function __construct(IReader $reader)
    {
        $this->reader = $reader;
    }

    public function render()
    {
        $contextNames = $this->reader->getAllContextNames();
        $defaultContext = $this->reader->read('default');

        foreach ($contextNames as $name) {
            if ($name == 'default') {
                continue;
            }
            $context = $this->reader->read($name);
            $defaultContext->addChild($context);
        }

        $result = $this->calculateVulnMatrix($defaultContext);
        $matrix = $this->reduceComputedVulnsToHtml($result, 1, $result['max_depth']);
        return $matrix;
    }

    /**
     * @param Context $context
     * @param int $level
     * @return array
     */
    protected function calculateVulnMatrix(Context $context, $level = 1)
    {
        $result = ['rows' => 0, 'max_depth' => $level, 'level' => $level];

        $vulns = $this->calcComputedVulns($context);
        if (count($vulns)) {
            $result['vulnerabilities'] = $vulns;
            $result['rows']++;
        }

        if ($context->getFields()->count()) {
            $fields = [];
            foreach ($context->getFields() as $field) {
                $vulns = $this->calcComputedVulns($field);
                if (!count($vulns)) {
                    continue;
                }
                $fields[] = [
                    'name' => $field->getName(),
                    'source' => $field->getSource(),
                    'vulnerabilities' => $vulns
                ];
            }

            if (count($fields)) {
                $result['fields'] = $fields;
                $result['rows'] += count($fields);
            }
        }

        if ($context->hasChildren()) {
            $children = [];
            foreach ($context->getChildren() as $child) {
                if ($childResult = $this->calculateVulnMatrix($child, $level + 1)) {
                    $children[$child->getName()] = $childResult;

                    if ($childResult['rows']) {
                        $result['rows'] += $childResult['rows'];
                        $result['max_depth'] = ((int) $childResult['max_depth']) > $result['max_depth'] ? ((int) $childResult['max_depth']) : $result['max_depth'];
                    }
                }
            }

            if (count($children)) {
                $result['children'] = $children;
            }
        }

        if (!$result['rows']) {
            $result = null;

        } else {
            $result['name'] = $context->getName();
            $result['type'] = $context->getType();
            $result['url'] = $context->getURL();
            $result['description'] = $context->getRouteDescription();
            $result['technology'] = $context->getTechnologyLabel();
        }

        return $result;
    }

    /**
     * @param VulnerabilityHost $host
     * @return array
     */
    protected function calcComputedVulns(VulnerabilityHost $host) {
        $baseVulns = $this->calcVulnerableElementVulns($host->getVulnTree());

        if ($host instanceof Field && $host->getName() == 'userEmail') {
            //var_dump($baseVulns);exit;
        }
        $descriptor = null;
        if ($host instanceof Field) {
            $descriptor = $host->getDescriptor();
        }

        $chain = $host->getCheckChain();
        unset($chain[0]);

        if (!count($chain)) {
            return $baseVulns;
        }

        if (!$baseVulns['children']) {
            $baseVulns['children'] = [];
        }

        if ($descriptor) {
            foreach ($chain as $chainEl) {
                if ($chainEl === $host->getParent()) {
                    continue;
                }

                foreach ($chainEl->getFields() as $field) {
                    if ($field === $host) {
                        continue;
                    }

                    if ($field->matchesToDescriptor($descriptor)) {
                        $fieldVulns = $this->calcVulnerableElementVulns($field->getVulnTree(), null, true, true);

                        if (count($fieldVulns)) {
                            $baseVulns['children'][] = $fieldVulns;
                        }

                        break;
                    }
                }
            }
        }

        foreach ($chain as $chainEl) {
            $fieldVulns = $this->calcVulnerableElementVulns($chainEl->getVulnTree(), null, true, true);
            if (count($fieldVulns)) {
                $baseVulns['children'][] = $fieldVulns;
            }
        }

        if (!count($baseVulns['children'])) {
            unset($baseVulns['children']);
        }
        return $baseVulns;
    }

    /**
     * @param VulnerableElement $elem
     * @param null|\VulnModule\Vulnerability[] $parentVulns
     * @param bool $onlyChildren
     * @param bool $inherits
     * @return array
     */
    protected function calcVulnerableElementVulns(VulnerableElement $elem, $parentVulns = null, $onlyChildren = false,
                                                  $inherits = false)
    {
        $vulns = [];
        /** @var \VulnModule\Vulnerability[] $computedVulns */
        $computedVulns = $elem->getComputedVulnerabilities(VulnerableElement::COMPUTE_ONLY_ROOT);

        if (!$onlyChildren) {
            // Show disabled for any context except default and for conditional elements
            $showDisabledVulns = (boolean)(!$elem->getHost() || $elem->getHost()->getParent());
            $customVulns = [];
            $vulnList = !!$parentVulns ? $elem->getVulnerabilitySet()->getVulnerabilities() : $computedVulns;

            foreach ($vulnList as $vuln) {
                if (!$vuln) {
                    continue;
                }
                $hasOwnVuln = $elem->hasOwnVulnerability($vuln->getName());

                if ($vuln->isEnabled() || ($showDisabledVulns && $hasOwnVuln)) {
                    if (!$parentVulns || !$parentVulns[$vuln->getName()]->equalsTo($vuln)) {
                        $customVulns[$vuln->getName()]['props'] = $vuln->asArray();
                        $customVulns[$vuln->getName()]['inherited'] = $inherits || !$hasOwnVuln;
                        $customVulns[$vuln->getName()]['vuln'] = $vuln;
                    }
                }
            }

            if (count($customVulns)) {
                $vulns['vulns'] = $customVulns;
            }
        }

        if ($elem->hasChildren()) {
            $childVulns = [];
            foreach ($elem->getChildren() as $child) {
                if ($childVuln = $this->calcVulnerableElementVulns($child, $computedVulns, false, $inherits)) {
                    $childVulns[] = $childVuln;
                }
            }
            if (count($childVulns)) {
                $vulns['children'] = $childVulns;
            }
        }

        if ($elem instanceof ConditionalVulnerableElement) {
            $conditions = [];
            if ($elem->hasConditions()) {
                foreach ($elem->getConditions()->getConditions() as $condition) {
                    $conditions[$condition->getName()] = $condition->__toString();
                }
            }

            if (count($conditions)) {
                $vulns['conditions'] = $conditions;
            }
        }

        if (count($vulns)) {
            if ($inherits) {
                $vulns['inherited_block'] = true;
            }
        }

        return $vulns;
    }

    protected function reduceComputedVulnsToHtml($data) {
        $result = [];

        $tHead = '<thead><tr><th>URL</th>'
            . '<th>Field&nbsp;(Source)</th><th>Vulnerabilities</th><th>Details</th></tr></thead>';
        $result[] = '<table class="table table-responsive table-bordered table-vuln-matrix">'.$tHead.'<tbody>';


        $rows = $this->prepareRowsForComputedVulnsToHtml($data);

        usort($rows, function ($a, $b) {
            $cmp = strcmp($a['url'], $b['url']);
            if ($cmp != 0) {
                return $cmp;

            } else {
                $cmp = strcmp($a['chain'], $b['chain']);

                if ($cmp != 0) {
                    return $cmp;
                } else {
                    return strcmp($a['field'], $b['field']);
                }
            }
        });

        $result[] = implode("\n", array_map(function ($value) {
            return $value['html'];
        }, $rows));

        $result[] = '</tbody></table>';

        return ['html' => implode("\n", $result)];
    }

    protected function prepareRowsForComputedVulnsToHtml($data, $level = 1, $contextChain = [])
    {
        $result = [];

        $urlCell = '<td class="field-cell">' . $data['url'] . '</td>';

        if ($level > 1) {
            $contextChain[] = $data['name'];
        }

        $formattedContextChain = implode(' -> ', $contextChain);
        $formattedContextChain = $formattedContextChain ?: 'default';

        $descriptionCellData = 'Context chain: ' . $formattedContextChain;

        if ($data['technology']) {
            $descriptionCellData = implode('<br>', [$descriptionCellData, 'Technology: ' . $data['technology']]);
        }

        $descriptionCellData .= ($data['description'] ? ($formattedContextChain ? '<br>' : '') . $data['description'] : '');

        $detailsCell = '<td class="field-cell"><a href="#" class="js-show-vulns-details" data-details="' .
            htmlspecialchars($descriptionCellData, ENT_COMPAT, 'utf-8') . '">Details</a></td>';

        if ($data['vulnerabilities'] && ($realVulnCells = $this->renderVulnCells($data['vulnerabilities']))) {
            $vulnHtml = $urlCell . '<td class="field-cell js-field-cell"></td>' . $realVulnCells;
            $result[] = [
                'url' => $data['url'],
                'html' => '<tr class="table-row context-row">' . $vulnHtml . $detailsCell . '</tr>',
                'chain' => $formattedContextChain,
                'field' => ''
            ];
        }

        if ($data['fields']) {
            foreach($data['fields'] as $field) {
                if ($field['vulnerabilities']) {
                    $vulnHtml = $urlCell;
                    $fieldName = $field['name'] . '&nbsp;(' . $field['source'] . ')';
                    $vulnHtml .= '<td class="field-cell js-field-cell">'.$fieldName.'</td>';
                    $vulnHtml .= $this->renderVulnCells($field['vulnerabilities']);
                    $result[] = [
                        'url' => $data['url'],
                        'html' => '<tr class="table-row field-row">' . $vulnHtml . $detailsCell . '</tr>',
                        'chain' => $formattedContextChain,
                        'field' => $fieldName
                    ];
                }
            }
        }

        if ($data['children']) {
            foreach($data['children'] as $child) {
                $childResult = $this->prepareRowsForComputedVulnsToHtml($child, $level + 1, $contextChain);
                $result = array_merge($result, $childResult);
            }
        }

        return $result;
    }

    /**
     * Wraps vulnerability tree and chain in a table cell.
     * @param $existingVulnsData
     * @return string
     */
    public function renderVulnCells($existingVulnsData)
    {
        $vulnHtml = $this->renderVulnCellVulns($existingVulnsData);

        return $vulnHtml ? "<td class=\"vuln-cell js-vuln-cell\">" . $vulnHtml . "</td>" : '';
    }

    /**
     * Renders vulnerability tree and chain for matrix.
     * @param $existingVulnsData
     * @return string
     */
    public function renderVulnCellVulns($existingVulnsData)
    {
        $vulnHtml = [];
        $vulnNames = VulnerabilityFactory::instance()->getAllVulnerabilityNames();
        $existingVulns = $existingVulnsData['vulns'] ?: [];
        $existingConditions = $existingVulnsData['conditions'];
        $children = $existingVulnsData['children'];
        $condHtml = null;
        $childrenHtml = null;

        if (count($existingConditions)) {
            $condHtml = '<strong>[' . trim(implode('; ', $existingConditions)) . ']</strong>';
        }


        foreach ($vulnNames as $vulnName) {
            $isActiveVuln = array_key_exists($vulnName, $existingVulns);
            $content = null;
            if ($isActiveVuln) {
                $content = [];
                foreach ($existingVulns[$vulnName]['props'] as $propName => $propValue) {
                    if (in_array($propName, ['enabled', 'name'])) {
                        continue;
                    }
                    $content[] = $propName . ': ' . (is_bool($propValue) ? ($propValue ? 'Yes' : 'No') : $propValue);
                }
                $content = '<span class="js-vulnerability vuln ' . ($existingVulns[$vulnName]['props']['enabled'] ? 'vuln-enabled' : 'vuln-disabled') . '">'
                    . $vulnName . ($content ? '&nbsp;(' . implode(', ', $content) . ')' : '')
                    . ($existingVulns[$vulnName]['inherited'] ? ' <span class="js-vuln-tips vuln-tips">[inherit]</span>' : '') . '</span>';
            }
            $vulnHtml[] = $content;
        }
        $vulnHtml = array_filter($vulnHtml);

        if (is_array($children) && count($children)) {
            $childrenHtml = [];
            foreach ($children as $child) {
                $childrenHtml[] = $this->renderVulnCellVulns($child);
            }
            $childrenHtml = array_filter($childrenHtml);
            if (count($childrenHtml)) {
                $childrenHtml = trim(implode('<br>', $childrenHtml));
                if ($childrenHtml && ($condHtml || count($vulnHtml))) {
                    $childrenHtml = '<div class="vuln-block">' . $childrenHtml . '</div>';
                }
            }
        }

        if (!$childrenHtml && !count($vulnHtml)) {
            $condHtml = null;
        }

        if (empty($vulnHtml)) {
            $vulnHtml = null;
        }

        $vulnHtml = $vulnHtml ? trim(implode('<br>', $vulnHtml)) : null;
        return trim(implode('<br>', array_filter([$condHtml, $vulnHtml, $childrenHtml])));
    }
}